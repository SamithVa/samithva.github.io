{
  "hash": "d8a73095712aa67bd85fee182c1b3767",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Numpy\ndescription: NumPy is the fundamental package for scientific computing in Python\nauthor: Samith Va\ndate: '2024-03-22'\ncategories:\n  - numpy\n  - python\n  - vectorization\nimage: numpylogo.svg\nformat:\n  html:\n    code-fold: false\n---\n\n# Introduction\n\nWhat is numpy?\n: NumPy is the fundamental package for scientific computing in Python. The core of Numpy is the `ndarray` object, operations of this array are being performed in compiled code for performance. \n\nHow Numpy differ from standard Python sequences  ? Why using numpy ? \n: There are several different between Numpy and standard Python sequences: \n\n* NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically)\n* Elements within the same Numpy array must be the same data type.\n* Advanced mathematics operations can be done easily in Numpy (with less code and good performance)\n* A growing plethora of scientific and mathematical libraries\n\nWhy is numpy fast ? \n: Vectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place,\nof course, just “behind the scenes” in optimized, pre-compiled C code. Vectorized code has many advantages, among\nwhich are:\n\n* Vectorized code is more concise and easier to read (shorter code without a lot of for loops)\n* Fewer lines of code generally means fewer bugs\n\n\n# Commonly used Numpy Functions\n\n## Linspace\n\n`np.linspace(start, end, interval)` creates an array with evenly spaced float numbers over a specified interval.\n\n::: {#58cc1c55 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\na = np.linspace(10,100,10)\na\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\narray([ 10.,  20.,  30.,  40.,  50.,  60.,  70.,  80.,  90., 100.])\n```\n:::\n:::\n\n\n## Reshape\n`np.reshape()` reshape a numpy array to specific given shape `(n, m)`. In neural network when dealing with images, we usually need to flatten the image into 1 row array by using `.reshape(-1)`.\n\n::: {#5dfc105b .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n# Create a 2D array\ny = np.array([[1, 2, 3, 4],\n              [5, 6, 7, 8],\n              [9, 10, 11, 12]])\n# Reshape the array to 1D using -1\nflattened_y = y.reshape(-1)\nflattened_y\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])\n```\n:::\n:::\n\n\n## Where\n`np.where()` perform conditional operations on arrays and is somewhat similar to the ternary conditional operator `(condition ? value_if_true : value_if_false)` found in many programming languages.\n\n::: {#3798699f .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\na = np.arange(10)\nb = np.where(a>5, a, a**2)\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([ 0,  1,  4,  9, 16, 25,  6,  7,  8,  9])\n```\n:::\n:::\n\n\nFor more references visit [Numpy Documentation](https://numpy.org/doc/)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}